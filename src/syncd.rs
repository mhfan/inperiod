/****************************************************************
 * $ID: syncd.rs  	Thu 07 Nov 2024 13:50:42+0800               *
 *                                                              *
 * Maintainer: 范美辉 (MeiHui FAN) <mhfan@ustc.edu>              *
 * Copyright (c) 2024 M.H.Fan, All rights reserved.             *
 ****************************************************************/

#![allow(non_snake_case)] #![allow(unused)]
use std::{error::Error, fs::{self, File}, io::Write, path::PathBuf};
use reqwest::blocking::get as reqwest_get;  // XXX: reqwest::get(url).await?.text().await?;
use scraper::{Html, Selector};

fn main() -> Result<(), Box<dyn Error>> {   // cargo r --bin syncd -F syncdep
    //parse_electronegativity()?; // use data from pubchem
    parse_nist_asd()?;
    parse_oxstates()?;
    parse_pubchem()?;
    parse_ciaaw()?;
    Ok(())
}

const HEADER: &[u8] = b"\n// Auto-generated by syncd.rs, DO NOT EDIT.\n";

/// https://en.wikipedia.org/wiki/Electronegativity
fn parse_electronegativity() -> Result<(), Box<dyn Error>> {
    let document = Html::parse_document(&reqwest_get(
        "https://en.wikipedia.org/wiki/Electronegativities_of_the_elements_(data_page)")?.text()?);
    let Some(table) = document.select(
        &Selector::parse("table.wikitable.sortable")?).next()
    else { return Err("Electronegativity table not found".into()) };

    let mut file = File::create(PathBuf::from("src").join("en_pauling.rs"))?;
    //let mut file = std::io::stdout();
    file.write_all(HEADER)?;    file.write_all(b"\nimpl super::ChemElem {\n")?;
    file.write_all(b"    pub const fn en_pauling(&self) -> Option<f32> {\n")?;
    file.write_all(b"        Some(match self.atomic_number() {\n")?;

    let td_selector = Selector::parse("td")?;
    for row in table.select(&Selector::parse("tr")?).skip(1) {
        let cells = row.select(&td_selector).collect::<Vec<_>>();
        let en = cells[3].text().next().unwrap_or("");
        if  en == "no data" { continue }
        let an = cells[0].text().next().unwrap_or("");
        file.write_fmt(format_args!("            {an:>3} => {en},\n"))?;
    }

    file.write_all(b"            _   => return None\n        })\n    }\n}\n\n")?;
    file.flush()?;  Ok(())
}

/// https://en.wikipedia.org/wiki/Oxidation_state
fn parse_oxstates() -> Result<(), Box<dyn Error>> {
    let document = Html::parse_document(&reqwest_get(
        "https://en.wikipedia.org/wiki/Template:List_of_oxidation_states_of_the_elements")?.text()?);
    let Some(table) = document.select(
        &Selector::parse("table.wikitable.sortable")?).next()
    else { return Err("Oxidation states table not found".into()) };

    let mut file = File::create(PathBuf::from("src").join("ostates.rs"))?;
    file.write_all(HEADER)?;    file.write_all(b"\nimpl super::ChemElem {\n")?;
    file.write_all(b"    pub const fn oxidation_states(&self) -> (&'static [i8], &'static [i8]) {\n")?;
    file.write_all(b"        let all: &'static [i8] = match self.atomic_number() {\n")?;

    let td_selector = Selector::parse("td")?;
    let mut os_all = vec![[None; 15]; inperiod::ChemElem::MAX as usize];
    for row in table.select(&Selector::parse("tr")?).skip(4) {
        let cells = row.select(&td_selector).collect::<Vec<_>>();

        let an = cells[0].text().next().unwrap_or("").trim().parse::<usize>()?;
        let states = &mut os_all[an];   assert!(18 < cells.len());

        for (i, cell) in cells[3..18].iter().enumerate() {
            if !cell.text().collect::<String>().replace('−', "-").trim()
                .parse::<i8>().is_ok_and(|x| x == i as i8 - 5) { continue }
            states[i] = Some(cell.descendent_elements()
                .any(|x| x.value().name() == "b")); // "span"
        }

        if states.iter().all(|&x| x.is_none()) { file.write_all(b"\n")?; continue }
        file.write_fmt(format_args!("            {an:>3} => &[ "))?;
        for (i, &x) in states.iter().enumerate() {
            if x.is_none() { file.write_all(b"   ")?; } else {
                file.write_fmt(format_args!("{:2},", i as i8 - 5 ))?; }
        }   file.write_all(b"],\n")?;
    }   file.write_all(b"            _   => &[]\n        };\n")?;

    file.write_all(b"\n        let main: &'static [i8] = match self.atomic_number() {\n")?;
    for (an, states) in os_all.iter().enumerate().skip(1) {
        if states.iter().all(|&x| x.is_none_or(|x| !x)) { continue }
        file.write_fmt(format_args!("            {an:>3} => &[ "))?;

        for (i, state) in states.iter()
            .enumerate().filter(|&(i, &x)| x.is_some_and(|x| x)) {
            file.write_fmt(format_args!("{:2},", i as i8 - 5 ))?;
        }   file.write_all(b" ],\n")?;
    }   file.write_all(b"            _   => &[]\n        };\n")?;

    file.write_all(b"\n        (main, all)\n    }\n}\n\n")?;
    file.flush()?;  Ok(())
}

/// https://www.nist.gov/pml/periodic-table-elements
/// https://physics.nist.gov/PhysRefData/ASD/ionEnergy.html
fn parse_nist_asd() -> Result<(), Box<dyn Error>> {
    let path = PathBuf::from("nist_asd.csv");
    let content = if path.exists() { fs::read_to_string(path)? } else {
        reqwest_get("https://physics.nist.gov/cgi-bin/ASD/ie.pl?spectra=h-Og&submit=Retrieve+Data&units=1&format=2&order=0&at_num_out=on&sp_name_out=on&shells_out=on&level_out=on&e_out=0&unc_out=on")?.text()?
    };

    /* for line in content.lines() {
        let fields = line.split(',').collect::<Vec<_>>();
        if  fields.get(1).is_none_or(|&x| !x.ends_with(" I\"\"\"")) { continue }
        let fields = fields.iter().map(|&x|
            x.trim_start_matches("\"=\"\"").trim_end_matches("\"\"\"")).collect::<Vec<_>>();
        println!("{}", fields.join(", "));
    } */

    let mut file = File::create(PathBuf::from("src").join("nist_asd.rs"))?;
    file.write_all(HEADER)?;    file.write_all(b"\nimpl super::ChemElem {\n")?;
    file.write_all(b"    pub const fn ionization_energy(&self) -> Option<(f64, f64)> {\n")?;
    file.write_all(b"        Some(match self.atomic_number() {\n")?;

    let mut fil2 = File::create(PathBuf::from("src").join("ground_level.rs"))?;
    fil2.write_all(HEADER)?;    fil2.write_all(b"\nimpl super::ChemElem {\n")?;
    fil2.write_all(b"    pub const fn ground_level(&self) -> Option<(&'static str, &'static str, &'static str)> {\n")?;
    fil2.write_all(b"        Some(match self.atomic_number() {\n")?;

    let mut reader = csv::ReaderBuilder::new()
        .flexible(true).from_reader(content.as_bytes());
    for result in reader.records() {
        let record = result?;   // XXX: extract and store data of all levels?
        if  record.get(1).is_none_or(|x| !x.ends_with(" I\"")) { continue }

        let fields = record.iter().map(|x|
            x.trim_start_matches("=\"").trim_end_matches("\"")).collect::<Vec<_>>();
        let (an, state, uncert) = (fields[0], fields[3], fields[7]);
        //println!("{}", fields.join(", "));

        file.write_fmt(format_args!("            {an:>3} => ({}, {}),\n",
            fields[5], if uncert.is_empty() { "0." } else { uncert }))?;

        if let Some((s1, s2)) = state[1..].split_once(['<', '0']) {
            let s2 = if s2.is_empty() { "0" } else { s2.trim_end_matches('>') };
            if  an == "82" && !state.starts_with(char::is_numeric) {    // XXX:
                fil2.write_all(b"             82 => (\"3\", \"P\" , \"0\"),\n")?;
                 eprintln!("{an}: {state:?} ?");    continue
            }
            fil2.write_fmt(format_args!("            {an:>3} => ({:?}, {:?}{}, {s2:?}),\n",
                &state[..1], s1.replace('*', "°"), if s1.len() == 1 { " " } else { "" }))?;
        } else { eprintln!("{an}: {state:?} ?") }   // 106 ~ 108
    }
    //fil2.write_all(b"            106 => (\"5\", \"D\" , \"0\"),\n")?;
    //fil2.write_all(b"            107 => (\"6\", \"S\" , \"5/2\"),\n")?;
    //fil2.write_all(b"            108 => (\"5\", \"D\" , \"4\"),\n")?;

    file.write_all(b"            _   => return None\n        })\n    }\n}\n\n")?;
    fil2.write_all(b"            _   => return None\n        })\n    }\n}\n\n")?;
    fil2.flush();   file.flush()?;  Ok(())
}

/// https://ciaaw.org/atomic-weights.htm
fn parse_ciaaw() -> Result<(), Box<dyn Error>> {
    let tr_selector = Selector::parse("tr")?;
    let td_selector = Selector::parse("td")?;
    let mut am_all = vec![""; inperiod::ChemElem::MAX as usize];

    let document = Html::parse_document(&reqwest_get(
        "https://ciaaw.org/radioactive-elements.htm")?.text()?);
    if let Some(table) = document.select(&Selector::parse("tbody")?).next() {
        let (mut half_life, mut atomic_number) = ("", 0usize);
        fn parse_half_life(input: &str) -> f32 {
            input.trim_start_matches(|c: char| !c.is_ascii_digit())
                .split_once(['(', ' ']).and_then(|(x, _)|
                    x.trim_start().parse::<f32>().ok()).unwrap_or(0.)
        }

        for row in table.select(&tr_selector) {
            let cells = row.select(&td_selector).collect::<Vec<_>>();
            if  cells.len() < 5 {   if cells.len() < 2 { continue }
                let hl2 = parse_half_life(cells[1].text().next().unwrap_or(""));
                if parse_half_life(half_life) < hl2 {
                    am_all[atomic_number] = cells[0].text().next().unwrap_or("");
                    //println!("{}: {} *", atomic_number, am_all[atomic_number]);
                }   continue
            }

            atomic_number = cells[0].text().next().unwrap_or("").trim().parse()?;
            am_all[atomic_number] = cells[3].text().next().unwrap_or("");
            half_life = cells[4].text().next().unwrap_or("");
        }
    }

    let mut file = File::create(PathBuf::from("src").join("ciaaw.rs"))?;
    file.write_all(HEADER)?;
    file.write_all(b"\nuse super::{ChemElem, AtomicWeight::{self, *}};\n\nimpl ChemElem {\n")?;
    file.write_all(b"    pub const fn atomic_weight(&self) -> &AtomicWeight {\n")?;

    file.write_all(b"const MASS: [AtomicWeight; ChemElem::MAX as usize] = [ MassNumber(0),\n")?;
    let document = Html::parse_document(&reqwest_get(
        "https://ciaaw.org/abridged-atomic-weights.htm")?.text()?);

    if let Some(table) = document.select(&Selector::parse("table")?).next() {
        for row in table.select(&tr_selector) {
            let cells: Vec<_> = row.select(&td_selector).collect();
            if  cells.len() < 4 { continue }

            let an = cells[0].text().next().unwrap_or("").trim().parse::<usize>()?;
            let atomic_weight  = cells[3].text().next().unwrap_or("").trim();
            if let Some((value, uncerntainty)) = atomic_weight.split_once('±') {
                file.write_fmt(format_args!("    Abridged {{ value: {:6}, uncertainty: {} }},\n",
                    value.trim_end(), uncerntainty.trim_start()))?;
            } else {
                file.write_fmt(format_args!("    MassNumber({}),\n", am_all[an].trim()))?;
            }
        }
    }

    file.write_all(b"];\n        &MASS[*self as usize]\n    }\n")?;
    file.write_all(b"}\n\n")?;  file.flush()?;  Ok(())
}

/// https://pubchem.ncbi.nlm.nih.gov/periodic-table/
fn parse_pubchem() -> Result<(), Box<dyn Error>> {
    use serde::Deserialize;
    #[derive(Deserialize)] struct AllElem { Table: Table, }
    #[derive(Deserialize)] struct Table { Columns: Columns, Row: Vec<Row>, }
    #[derive(Deserialize)] struct Columns { Column: Vec<String>, }
    #[derive(Deserialize)] struct Row { Cell: Vec<String>, }

    let path = PathBuf::from("PubChemElements_all.json");
    let content = if path.exists() { fs::read_to_string(path)? } else {
        reqwest_get("https://pubchem.ncbi.nlm.nih.gov/rest/pug/periodictable/JSON")?.text()?
    };  let elem_all: AllElem = serde_json::from_str(&content)?;

    //let path = PathBuf::from(env::var("OUT_DIR")?).join("pubchem.rs"))?;
    let mut file = File::create(PathBuf::from("src").join("pubchem.rs"))?;
    file.write_all(HEADER)?;
    file.write_all(b"\nuse super::{ChemElem, ElectronCFG, Subshell};\n\nimpl ChemElem {\n")?;

    let column = &elem_all.Table.Columns.Column;
    let Some(an_pos) = column.iter().position(|x| x == "AtomicNumber")
    else { return Err("AtomicNumber not found".into()) };

    /* if let Some(pos) = column.iter().position(|x| x == "AtomicMass") {
        file.write_all(b"    pub const fn atomic_mass(&self) -> f64 {\n")?;

        file.write_all(b"const MASS: [f64; ChemElem::MAX as usize] = [ 0.,\n")?;
        for row in elem_all.Table.Row.iter() {
            let s = &row.Cell[pos];
            file.write_fmt(format_args!("    {s}{},\n", if s.contains('.') { "" } else { "." }))?;
        }   file.write_all(b"];\n")?;

        file.write_all(b"        MASS[*self as usize]\n    }\n\n")?;
    } */

    fn camel_to_snake(camel_case: &str) -> String {
        let mut snake_case = String::with_capacity(camel_case.len() * 2);
        for c in camel_case.chars().peekable() {
            if c.is_ascii_uppercase() {
                if !snake_case.is_empty() { snake_case.push('_'); }
                snake_case.push(c.to_ascii_lowercase());
            } else { snake_case.push(c); }
        }       snake_case
    }

    let mut extract_data = |name: &str| -> Result<(), Box<dyn Error>> {
        let Some(pos) = column.iter().position(|x| x == name)
        else { return Err(format!("{name} not found").into()) };
        file.write_fmt(format_args!("    pub const fn {}(&self) -> Option<f32> {{\n",
            camel_to_snake(name)))?;
        file.write_all(b"        Some(match self.atomic_number() {\n")?;

        for row in elem_all.Table.Row.iter() {
            let s = &row.Cell[pos];     if s.is_empty() { continue }
            file.write_fmt(format_args!("            {:>3} => {s}{},\n", row.Cell[an_pos],
                if s.contains('.') { "" } else { "." }))?;
        }
        file.write_all(b"            _   => return None\n        })\n    }\n\n")?;  Ok(())
    };

    extract_data("AtomicRadius")?;      // u16?
    //extract_data("IonizationEnergy")?;
    extract_data("ElectronAffinity")?;
    extract_data("Electronegativity")?;
    extract_data("MeltingPoint")?;
    extract_data("BoilingPoint")?;
    extract_data("Density")?;

    // https://en.wikipedia.org/wiki/Electron_configurations_of_the_elements_(data_page)
    if let Some(pos) = column.iter().position(|x| x == "ElectronConfiguration") {
        file.write_all(b"    pub const fn electron_configuration(&self) -> &ElectronCFG {\n")?;
        file.write_all(b"const ECFG: [ElectronCFG; ChemElem::MAX as usize] = [\n")?;
        file.write_all(b"    ElectronCFG { base: None, valence: &[] },\n")?;

        for row in elem_all.Table.Row.iter() {
            let ecfg = row.Cell[pos].as_str();
            let (base, rest) = ecfg.trim_start().find(']')
                .map_or(("", ecfg), |pos| (&ecfg[1..pos], &ecfg[pos+1..]));

            file.write_all(b"    ElectronCFG { base: ")?;
            if base.is_empty() { file.write_all(b"None,")?; } else {
                file.write_fmt(format_args!("Some(ChemElem::{base}),"))?;
            }   file.write_all(b" valence: &[\n")?;

            let mut coll = rest.split_ascii_whitespace().collect::<Vec<_>>();
            coll.sort_by(|&a, &b| a.as_bytes()[0].cmp(&b.as_bytes()[0]));

            for part in coll {
                if part.starts_with('(') { continue }
                let p3 = if 2 < part.len() { &part[2..] } else { "1" };
                file.write_fmt(format_args!(
                    "        Subshell {{ level: {}, orbital: b'{}', ecount: {:>2} }},\n",
                    &part[..1], &part[1..2], p3))?;
            }   file.write_all(b"    ] },\n")?;
        }       file.write_all(b"];\n")?;
        file.write_all(b"        &ECFG[*self as usize]\n    }\n")?;
    }

    file.write_all(b"}\n\n")?;  file.flush()?;  Ok(())
}

